import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

/* Name: Anthony Frazier
 * Class: CSCE355
 * Due Date: November 21, 2017
 * Assignment: Programming Assignment.
 * 
 * Minimizing a DFA:
 * The input DFA is read from a text file given as the first command line
 * argument, and the output DFA is written to standard output. You should use the table-of-distinguishable-states
 * method described in class to do the minimization. You do not need
 * to output the distinguishability table, but you may optionally do so to standard error if you
 * want. Both the input and output DFA descriptions adhere to the format described below.
 * The ordering of the states of the output DFA is not completely determined, so correct answers
 * may differ up to the ordering of states. That's okay, we'll take that into account using our
 * own script that determines whether two DFAs are the same up to reordering states.
*/
public class MyMinimizer {
	
	static final int DUMMY_STATE_NUM = 999999999;

	
public static void main(String[] args) throws IOException
{	//Set up error output. (This code is directly copied from a stack overflow example)
	FileOutputStream f = new FileOutputStream("error_log.txt");	 
	System.setErr(new PrintStream(f));
	
	DFA newDFA = null;
	newDFA = Simulate(args);
	newDFA = Minimize(newDFA);
	
} // end main

public static DFA Simulate(String[] args) throws IOException
{	
	// This code is only slightly modified from my MySimulator.java
	File inputFile1 = null;	
	DFA newDFA = new DFA();
	
	inputFile1 = new File(args[0]);
	
	// Use our DFA class to parse over the description, creating a DFA
	newDFA = DFA.ScanDescription(inputFile1);
	
	return newDFA;
} // end Simulate();

public static DFA Minimize(DFA dfa)
{	/* Two states are considered equivalent when:
	* If state1 reads string w and ends in an accepting state, and state2 reads same string w and ends in an accepting state
	* OR If state1 reads string w and ends in an non-accepting state, and state2 reads same string w and ends in an non-accepting state
	* 
	* Step One: Remove states that are unreachable from start state
	* Step Two: Set up two lists: one that represents equivalent states and one that represents distinguishable states
	* 	For 0 equivalence, any state that is accepting is distinguishable
	* 	For 1 equivalence, these are states that transition to the same state over alphabet 'whatever'
	*   For n equivalence, these are states that are equivalent in n-1, and are still equiv in 'n' alphabet transitions
	*/
	
	int states = dfa.getStates();
	
	
	
	
	
	// Declare an int[][] array named newTrans that will contain our new, minimized transition table
	int[][] newTrans = null;
	// Declare an array named stateDone that will contain a list of states
	//  already in our new transition table; Initialize this array
	//  with: DUMMY_STATE_NUM value
	int[] stateDone = new int[dfa.getStates()];
	for (int i = 0; i < stateDone.length; i++)
	{
		stateDone[i] = DUMMY_STATE_NUM;
	}

	return null;
}
}
